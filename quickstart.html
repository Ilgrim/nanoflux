---
layout: null
section-type: quickstart
title: Quickstart
---
## Quickstart

<small>Or go straight to <a href="./docs/">documentation</a></small>

Pull package from <a href="https://www.npmjs.com/package/nanoflux" target="_blank">npm</a> or <a href="http://bower.io/search/?q=nanoflux" target="_blank">bower</a>

<pre><code class="shell">

    npm install nanoflux --save
    bower install nanoflux

</code></pre>

Setup NanoFlux globally at the application's entry point, before any usage of NanoFlux. <br/>
In this scenario we pretend to use a single *Dispatcher* only, <br/>
although NanoFlux provides the ability to create multiple dispatchers.
<pre><code class="javascript">
    import NanoFlux from '../node_modules/nanoflux/dist/nanoflux.min';
    window.NanoFlux = NanoFlux;
    // creates a named dispatcher, which is also accessible using NanoFlux.getDispatcher('dispatcher');
    // Here we use the 'fluxy' way, where actions are part of the dispatcher.
    // This way we avoid the need of additional action creators, reducing code.
    // Note: The action names are used for stores function mapping, e.g. 'addProduct' maps to 'onAddProduct'
    window.NanoFlux.Dispatcher = NanoFlux.createDispatcher('dispatcher', ['addProduct','loadProducts'] );
</code></pre>


Define your *Store* in a separate file.
<pre><code class="javascript">
    // it's highly recommended to use immutable structures
    import Immutable from '../node_module/seamless-immutable/seamless-immutable.production.min';
    import ProductService from './services/productservice';

    var _products = null;

    // creates a store with name 'productStore'. It is assumed that NanoFlux is already global.
    // the store is accessible using NanoFlux.getStore('productStore')
    var store = NanoFlux.createStore('productStore', {
        // a state getter usable by subscribed views
        getProducts : {
            return _products; // remember: it's immutable
        },
        // onLoadProducts is automatically mapped (convention) to action 'loadProducts'
        onLoadProducts : function(){
            ProductService.loadProducts().then( (products) => {
                    _products = Immutable(products);
                    this.notify(); // notifies all subscribed views
                }
            );
        },
        onAddProduct : function(product){
            _products = _products.concat(Immutable(product));
            this.notify();
        }
    });

    // Now, we connect the store to our globally set dispatcher.
    NanoFlux.Dispatcher.connectTo(store);
</code></pre>

Pronto! Now, we are ready to use our store in our components.
<pre><code class="javascript">
    class ProductContainer extends React.Component{

        constructor(props){
            super(props);
            this.state = { products : [] };
            this.productStore = NanoFlux.getStore('productStore'); // getting our store
            // next line binds 'this' to our callback, so there's no need for additional binding
            this.subscription = this.productStore.subscribe(this, this.onProductsUpdated);
        }

        onProductsUpdated(){
            let products = this.productStore.getProducts();
            this.setState({ products : products});
        }

        componentDidMount(){
            NanoFlux.Dispatcher.loadProducts();
        }

        componentWillUnmount(){
            // stop listening to store changes.
            this.subscription.unsubscribe();
        }

        render(){
            // ... your render stuff
        )
    }
});

</code></pre>

